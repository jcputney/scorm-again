{"version":3,"file":"cross-frame-lms.min.js","sources":["../src/CrossFrameLMS.ts"],"sourcesContent":["// src/CrossFrameLMS.ts\nimport { MessageData, MessageResponse } from \"./types/CrossFrame\";\nimport { IBaseAPI } from \"./interfaces/IBaseAPI\";\n\n/**\n * Server‐side SCORM adapter running in your LMS frame (lms.example.com).\n * Listens for postMessage from child (content) frames, invokes real API,\n * and posts back { messageId, result, error }.\n */\nexport default class CrossFrameLMS {\n  private readonly _api: IBaseAPI;\n  private readonly _origin: string;\n\n  constructor(api: IBaseAPI, targetOrigin: string = \"*\") {\n    this._api = api;\n    this._origin = targetOrigin;\n    window.addEventListener(\"message\", this._onMessage.bind(this));\n  }\n\n  private _onMessage(ev: MessageEvent) {\n    // Validate the message origin unless all origins are allowed\n    if (this._origin !== \"*\" && ev.origin !== this._origin) {\n      return;\n    }\n\n    const msg = ev.data as MessageData;\n    if (!msg?.messageId || !msg.method || !ev.source) return;\n\n    this._process(msg, ev.source as Window);\n  }\n\n  private _process(msg: MessageData, source: Window) {\n    const sendResponse = (result?: any, error?: { message: string; stack?: string }) => {\n      const resp: MessageResponse = { messageId: msg.messageId };\n      if (result !== undefined) resp.result = result;\n      if (error !== undefined) resp.error = error;\n      source.postMessage(resp, this._origin);\n    };\n\n    try {\n      const fn = (this._api as any)[msg.method];\n      if (typeof fn !== \"function\") {\n        sendResponse(undefined, { message: `Method ${msg.method} not found` });\n        return;\n      }\n\n      const result = fn.apply(this._api, msg.params);\n\n      if (result && typeof (result as Promise<any>).then === \"function\") {\n        (result as Promise<any>)\n          .then((r) => sendResponse(r))\n          .catch((e: any) => sendResponse(undefined, { message: e.message, stack: e.stack }));\n      } else {\n        sendResponse(result);\n      }\n    } catch (e: any) {\n      sendResponse(undefined, { message: e.message, stack: e.stack });\n    }\n  }\n}\n"],"names":["constructor","api","targetOrigin","arguments","length","undefined","this","_api","_origin","window","addEventListener","_onMessage","bind","ev","origin","msg","data","messageId","method","source","_process","sendResponse","result","error","resp","postMessage","fn","message","apply","params","then","r","catch","e","stack"],"mappings":"kDASA,MAIEA,WAAAA,CAAYC,GAA2C,IAA5BC,EAAAC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAuB,IAChDG,KAAKC,KAAON,EACZK,KAAKE,QAAUN,EACfO,OAAOC,iBAAiB,UAAWJ,KAAKK,WAAWC,KAAKN,MAC1D,CAEQK,UAAAA,CAAWE,GAEjB,GAAqB,MAAjBP,KAAKE,SAAmBK,EAAGC,SAAWR,KAAKE,QAC7C,OAGF,MAAMO,EAAMF,EAAGG,KACVD,GAAKE,WAAcF,EAAIG,QAAWL,EAAGM,QAE1Cb,KAAKc,SAASL,EAAKF,EAAGM,OACxB,CAEQC,QAAAA,CAASL,EAAkBI,GACjC,MAAME,EAAeA,CAACC,OAAcC,KAClC,MAAMC,EAAwB,CAAEP,UAAWF,EAAIE,gBAChC,IAAXK,SAAsBE,EAAKF,OAASA,aAC1B,IAAVC,IAAqBC,EAAKD,MAAQA,GACtCJ,EAAOM,YAAYD,EAAMlB,KAAKE,UAGhC,IACE,MAAMkB,EAAMpB,KAAKC,KAAaQ,EAAIG,QAClC,GAAkB,mBAAPQ,EAET,YADAL,OAAa,EAAW,CAAEM,QAAS,UAAUZ,EAAIG,qBAInD,MAAMI,OAASI,EAAGE,MAAMtB,KAAKC,KAAMQ,EAAIc,QAEnCP,QAAmD,mBAAjCA,OAAwBQ,KAC3CR,OACEQ,KAAMC,GAAMV,EAAaU,IACzBC,MAAOC,GAAWZ,OAAa,EAAW,CAAEM,QAASM,EAAEN,QAASO,MAAOD,EAAEC,SAE5Eb,EAAaC,OAEjB,OAASW,GACPZ,OAAa,EAAW,CAAEM,QAASM,EAAEN,QAASO,MAAOD,EAAEC,OACzD,CACF"}