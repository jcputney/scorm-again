{"version":3,"file":"cross-frame-facade.js","sources":["../../src/facades/CrossFrameFacade.ts"],"sourcesContent":["/**\n * CrossFrameFacade.ts\n *\n * This file implements a cross-frame facade for the scorm-again API.\n * It allows communication between frames from different domains using the postMessage API.\n */\n\nimport BaseAPI from \"../BaseAPI\";\n\n/**\n * Type for the message data\n */\nexport type MessageData = {\n  messageId: string;\n  method: string;\n  params: unknown[];\n  sab?: SharedArrayBuffer;\n};\n\n/**\n * Type for the message response\n */\nexport type MessageResponse = {\n  messageId: string;\n  result?: unknown;\n  error?: {\n    message: string;\n    stack?: string;\n  };\n  sab?: SharedArrayBuffer;\n};\n\n/**\n * Interface for the CrossFrameFacade\n */\nexport interface ICrossFrameFacade {\n  /**\n   * Initialize the SCORM API (SCORM 1.2 style) - Asynchronous version\n   * @returns Promise that resolves to true if initialization was successful\n   */\n  initialize(): Promise<boolean>;\n\n  /**\n   * Initialize the SCORM API (SCORM 1.2 style) - Synchronous version\n   * @returns \"true\" if initialization was successful, \"false\" otherwise\n   */\n  lmsInitialize(): string;\n\n  /**\n   * Initialize the SCORM API (SCORM 2004 style) - Asynchronous version\n   * @returns Promise that resolves to true if initialization was successful\n   */\n  Initialize(): Promise<boolean>;\n\n  /**\n   * Initialize the SCORM API (SCORM 2004 style) - Synchronous version\n   * @returns \"true\" if initialization was successful, \"false\" otherwise\n   */\n  LMSInitialize(): string;\n\n  /**\n   * Terminate the SCORM API (SCORM 1.2 style) - Asynchronous version\n   * @returns Promise that resolves to true if termination was successful\n   */\n  terminate(): Promise<boolean>;\n\n  /**\n   * Terminate the SCORM API (SCORM 1.2 style) - Synchronous version\n   * @returns \"true\" if termination was successful, \"false\" otherwise\n   */\n  lmsFinish(): string;\n\n  /**\n   * Terminate the SCORM API (SCORM 2004 style) - Asynchronous version\n   * @returns Promise that resolves to true if termination was successful\n   */\n  Terminate(): Promise<boolean>;\n\n  /**\n   * Terminate the SCORM API (SCORM 2004 style) - Synchronous version\n   * @returns \"true\" if termination was successful, \"false\" otherwise\n   */\n  LMSFinish(): string;\n\n  /**\n   * Get a value from the SCORM API (SCORM 1.2 style) - Asynchronous version\n   * @param element The CMI element to get\n   * @returns Promise that resolves to the value of the CMI element\n   */\n  getValue(element: string): Promise<string>;\n\n  /**\n   * Get a value from the SCORM API (SCORM 1.2 style) - Synchronous version\n   * @param element The CMI element to get\n   * @returns The value of the CMI element\n   */\n  lmsGetValue(element: string): string;\n\n  /**\n   * Get a value from the SCORM API (SCORM 2004 style) - Asynchronous version\n   * @param element The CMI element to get\n   * @returns Promise that resolves to the value of the CMI element\n   */\n  GetValue(element: string): Promise<string>;\n\n  /**\n   * Get a value from the SCORM API (SCORM 2004 style) - Synchronous version\n   * @param element The CMI element to get\n   * @returns The value of the CMI element\n   */\n  LMSGetValue(element: string): string;\n\n  /**\n   * Set a value in the SCORM API (SCORM 1.2 style) - Asynchronous version\n   * @param element The CMI element to set\n   * @param value The value to set\n   * @returns Promise that resolves to true if the value was set successfully\n   */\n  setValue(element: string, value: string | number | boolean): Promise<boolean>;\n\n  /**\n   * Set a value in the SCORM API (SCORM 1.2 style) - Synchronous version\n   * @param element The CMI element to set\n   * @param value The value to set\n   * @returns \"true\" if the value was set successfully, \"false\" otherwise\n   */\n  lmsSetValue(element: string, value: string | number | boolean): string;\n\n  /**\n   * Set a value in the SCORM API (SCORM 2004 style) - Asynchronous version\n   * @param element The CMI element to set\n   * @param value The value to set\n   * @returns Promise that resolves to true if the value was set successfully\n   */\n  SetValue(element: string, value: string | number | boolean): Promise<boolean>;\n\n  /**\n   * Set a value in the SCORM API (SCORM 2004 style) - Synchronous version\n   * @param element The CMI element to set\n   * @param value The value to set\n   * @returns \"true\" if the value was set successfully, \"false\" otherwise\n   */\n  LMSSetValue(element: string, value: string | number | boolean): string;\n\n  /**\n   * Commit changes to the LMS (SCORM 1.2 style) - Asynchronous version\n   * @returns Promise that resolves to true if the commit was successful\n   */\n  commit(): Promise<boolean>;\n\n  /**\n   * Commit changes to the LMS (SCORM 1.2 style) - Synchronous version\n   * @returns \"true\" if the commit was successful, \"false\" otherwise\n   */\n  lmsCommit(): string;\n\n  /**\n   * Commit changes to the LMS (SCORM 2004 style) - Asynchronous version\n   * @returns Promise that resolves to true if the commit was successful\n   */\n  Commit(): Promise<boolean>;\n\n  /**\n   * Commit changes to the LMS (SCORM 2004 style) - Synchronous version\n   * @returns \"true\" if the commit was successful, \"false\" otherwise\n   */\n  LMSCommit(): string;\n\n  /**\n   * Get the last error code (SCORM 1.2 style) - Asynchronous version\n   * @returns Promise that resolves to the last error code as a string\n   */\n  getLastError(): Promise<string>;\n\n  /**\n   * Get the last error code (SCORM 1.2 style) - Synchronous version\n   * @returns The last error code as a string\n   */\n  lmsGetLastError(): string;\n\n  /**\n   * Get the last error code (SCORM 2004 style) - Asynchronous version\n   * @returns Promise that resolves to the last error code as a string\n   */\n  GetLastError(): Promise<string>;\n\n  /**\n   * Get the last error code (SCORM 2004 style) - Synchronous version\n   * @returns The last error code as a string\n   */\n  LMSGetLastError(): string;\n\n  /**\n   * Get the error string for an error code (SCORM 1.2 style) - Asynchronous version\n   * @param errorCode The error code\n   * @returns Promise that resolves to the error string\n   */\n  getErrorString(errorCode: string | number): Promise<string>;\n\n  /**\n   * Get the error string for an error code (SCORM 1.2 style) - Synchronous version\n   * @param errorCode The error code\n   * @returns The error string\n   */\n  lmsGetErrorString(errorCode: string | number): string;\n\n  /**\n   * Get the error string for an error code (SCORM 2004 style) - Asynchronous version\n   * @param errorCode The error code\n   * @returns Promise that resolves to the error string\n   */\n  GetErrorString(errorCode: string | number): Promise<string>;\n\n  /**\n   * Get the error string for an error code (SCORM 2004 style) - Synchronous version\n   * @param errorCode The error code\n   * @returns The error string\n   */\n  LMSGetErrorString(errorCode: string | number): string;\n\n  /**\n   * Get diagnostic information for an error code (SCORM 1.2 style) - Asynchronous version\n   * @param errorCode The error code\n   * @returns Promise that resolves to the diagnostic information\n   */\n  getDiagnostic(errorCode: string | number): Promise<string>;\n\n  /**\n   * Get diagnostic information for an error code (SCORM 1.2 style) - Synchronous version\n   * @param errorCode The error code\n   * @returns The diagnostic information\n   */\n  lmsGetDiagnostic(errorCode: string | number): string;\n\n  /**\n   * Get diagnostic information for an error code (SCORM 2004 style) - Asynchronous version\n   * @param errorCode The error code\n   * @returns Promise that resolves to the diagnostic information\n   */\n  GetDiagnostic(errorCode: string | number): Promise<string>;\n\n  /**\n   * Get diagnostic information for an error code (SCORM 2004 style) - Synchronous version\n   * @param errorCode The error code\n   * @returns The diagnostic information\n   */\n  LMSGetDiagnostic(errorCode: string | number): string;\n\n  /**\n   * Check if the API is currently initialized - Asynchronous version\n   * @returns Promise that resolves to true if the API is initialized\n   */\n  isInitialized(): Promise<boolean>;\n\n  /**\n   * Check if the API is currently initialized - Synchronous version\n   * @returns True if the API is initialized, false otherwise\n   */\n  getIsInitialized(): boolean;\n\n  /**\n   * Register an event listener\n   * @param event The event name\n   * @param callback The callback function\n   */\n  on(event: string, callback: (...args: unknown[]) => void): void;\n\n  /**\n   * Remove an event listener\n   * @param event The event name\n   * @param callback The callback function\n   */\n  off(event: string, callback: (...args: unknown[]) => void): void;\n}\n\n/**\n * Server-side facade that runs in the parent frame where the API is initialized.\n * This facade listens for messages from the client-side facade and proxies them to the actual API.\n */\nexport class CrossFrameLMS {\n  private readonly _api: BaseAPI;\n  private readonly _targetOrigin: string = \"*\";\n\n  /**\n   * Constructor\n   * @param {BaseAPI} api The API instance to use\n   * @param targetOrigin The target origin for postMessage (default: \"*\")\n   */\n  constructor(api: BaseAPI, targetOrigin?: string) {\n    this._api = api;\n\n    // Set target origin if provided\n    if (targetOrigin) {\n      this._targetOrigin = targetOrigin;\n    }\n\n    // Listen for messages from the client-side facade\n    window.addEventListener(\"message\", this._handleMessage.bind(this));\n\n    // Set up event forwarding\n    this._setupEventForwarding();\n  }\n\n  /**\n   * Handle messages from the client-side facade\n   * @param event The message event\n   */\n  private _handleMessage(event: MessageEvent) {\n    const data = event.data as MessageData;\n\n    // Ignore messages that don't have the expected format\n    if (!data || !data.messageId || !data.method) {\n      return;\n    }\n\n    // Process the message\n    this._processMessage(data, event.source as Window, event.origin);\n  }\n\n  /**\n   * Process a message from the client-side facade\n   * @param data The message data\n   * @param source The source window\n   * @param origin The origin of the message\n   */\n  private _processMessage(data: MessageData, source: Window, origin: string) {\n    const { messageId, method, params, sab } = data;\n    let result: any;\n    let error: any;\n\n    try {\n      // Call the appropriate method on the API\n      if (typeof (this._api as unknown as Record<string, Function>)[method] === \"function\") {\n        result = (this._api as unknown as Record<string, Function>)[method](...params);\n      } else {\n        throw new Error(`Method ${method} not found on API`);\n      }\n    } catch (e: unknown) {\n      if (e instanceof Error) {\n        error = {\n          message: e.message,\n          stack: e.stack,\n        };\n      } else {\n        error = {\n          message: String(e),\n        };\n      }\n    }\n\n    // Send the response back to the client-side facade\n    const response: MessageResponse = {\n      messageId,\n      result,\n      error,\n      sab,\n    };\n\n    source.postMessage(response, this._targetOrigin, sab ? [sab] : undefined);\n  }\n\n  /**\n   * Set up event forwarding from the API to the client-side facade\n   */\n  private _setupEventForwarding() {\n    // Forward all events from the API to the client-side facades\n    this._api.on(\"*\", (event: string, ...args: any[]) => {\n      // Get all frames that might contain client-side facades\n      // We get the frames each time an event is triggered to ensure we have the latest frames\n      const frames = Array.from(document.querySelectorAll(\"iframe\"));\n\n      // Send the event to all frames\n      frames.forEach((frame) => {\n        if (frame.contentWindow) {\n          frame.contentWindow.postMessage(\n            {\n              event,\n              args,\n            },\n            this._targetOrigin,\n          );\n        }\n      });\n    });\n  }\n}\n\n/**\n * Client-side facade that runs in the child frame where the module is loaded.\n * This facade sends messages to the server-side facade and provides the same interface as the actual API.\n */\nexport class CrossFrameAPI implements ICrossFrameFacade {\n  private _targetOrigin: string = \"*\";\n  private _pendingRequests: Map<\n    string,\n    {\n      resolve: (value: unknown) => void;\n      reject: (reason?: unknown) => void;\n      source?: Window; // Source window for forwarding responses\n    }\n  > = new Map();\n  private _eventListeners: Map<string, Set<(...args: unknown[]) => void>> = new Map();\n  private _messageIdCounter: number = 0;\n  private _childFrames: Set<Window> = new Set(); // Track child frames that have sent messages\n  private _isInitialized: boolean = false;\n  private _lastError: string = \"0\";\n  private _cache: Map<string, string> = new Map(); // Cache for synchronous operations\n  private _sabBuffers: Map<string, SharedArrayBuffer> = new Map();\n\n  private _syncCall(method: string, params: any[], timeoutMs = 5000): any {\n    // In a test environment, this method might be mocked\n    // so we need to ensure it's testable\n    try {\n      const sab = new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT);\n      const int32 = new Int32Array(sab);\n      const messageId = `${Date.now()}-sync-${this._messageIdCounter++}`;\n      // store sab for matching responses\n      this._sabBuffers.set(messageId, sab);\n      // send the call, transferring sab\n      window.parent.postMessage({ messageId, method, params, sab }, this._targetOrigin, [sab]);\n      // block until notified\n      const status = Atomics.wait(int32, 0, 0, timeoutMs);\n      // cleanup\n      this._sabBuffers.delete(messageId);\n      const pending = this._pendingRequests.get(messageId) || {};\n      this._pendingRequests.delete(messageId);\n      if (status === \"timed-out\") {\n        throw new Error(`SCORM ${method} timeout after ${timeoutMs}ms`);\n      }\n      if ((pending as any).error) throw (pending as any).error;\n      return (pending as any).result;\n    } catch (e) {\n      // If SharedArrayBuffer or Atomics are not available (e.g., in test environment)\n      // or if there's any other error, rethrow it to be handled by the caller\n      throw e;\n    }\n  }\n\n  /**\n   * Constructor\n   * @param targetOrigin The target origin for postMessage (default: \"*\")\n   */\n  constructor(targetOrigin?: string) {\n    // Set target origin if provided\n    if (targetOrigin) {\n      this._targetOrigin = targetOrigin;\n    }\n\n    // Listen for messages from the server-side facade and child frames\n    window.addEventListener(\"message\", this._handleMessage.bind(this));\n  }\n\n  /**\n   * Handle messages from the server-side facade and child frames\n   * @param event The message event\n   */\n  private _handleMessage(event: MessageEvent) {\n    const data = event.data;\n    const source = event.source as Window;\n\n    // Check if the message is from a child frame\n    const isFromChildFrame = source !== window.parent && source !== window;\n\n    // Handle method responses from parent frame\n    if (\n      data.messageId &&\n      (data.result !== undefined || data.error !== undefined) &&\n      !isFromChildFrame\n    ) {\n      this._handleMethodResponse(data);\n    }\n\n    // Handle method requests from child frames\n    if (data.messageId && data.method && isFromChildFrame) {\n      // Add the child frame to our set of known frames\n      this._childFrames.add(source);\n\n      // Forward the message to the parent frame, but keep track of the source\n      const { messageId, method, params } = data;\n      const forwardedMessageId = `forwarded-${messageId}`;\n\n      // Store the promise callbacks with the source window\n      this._pendingRequests.set(forwardedMessageId, {\n        resolve: (result) => {\n          // Forward the result back to the child frame\n          source.postMessage(\n            {\n              messageId,\n              result,\n            },\n            this._targetOrigin,\n          );\n        },\n        reject: (error) => {\n          // Forward the error back to the child frame\n          source.postMessage(\n            {\n              messageId,\n              error,\n            },\n            this._targetOrigin,\n          );\n        },\n        source,\n      });\n\n      // Forward the message to the parent frame\n      window.parent.postMessage(\n        {\n          messageId: forwardedMessageId,\n          method,\n          params,\n        },\n        this._targetOrigin,\n      );\n\n      // Set a timeout to clean up if no response is received\n      setTimeout(() => {\n        if (this._pendingRequests.has(forwardedMessageId)) {\n          const request = this._pendingRequests.get(forwardedMessageId);\n          this._pendingRequests.delete(forwardedMessageId);\n          if (request?.source) {\n            request.source.postMessage(\n              {\n                messageId,\n                error: {\n                  message: `Timeout waiting for response to method ${method}`,\n                },\n              },\n              this._targetOrigin,\n            );\n          }\n        }\n      }, 5000);\n    }\n\n    // Handle events from parent frame\n    if (data.event && !isFromChildFrame) {\n      this._handleEvent(data.event, ...(data.args || []));\n\n      // Forward events to child frames\n      this._forwardEventToChildFrames(data.event, data.args || []);\n    }\n  }\n\n  /**\n   * Handle a method response from the server-side facade\n   * @param data The response data\n   */\n  private _handleMethodResponse(data: MessageResponse) {\n    const { messageId, result, error } = data;\n    if (data.sab) {\n      const int32 = new Int32Array(data.sab);\n      Atomics.store(int32, 0, 1);\n      Atomics.notify(int32, 0);\n    }\n    const pendingRequest = this._pendingRequests.get(messageId);\n    if (pendingRequest) {\n      const { resolve, reject } = pendingRequest;\n      if (error) {\n        reject(error);\n      } else {\n        resolve(result);\n      }\n      this._pendingRequests.delete(messageId);\n    }\n  }\n\n  /**\n   * Handle an event from the server-side facade\n   * @param event The event name\n   * @param args The event arguments\n   */\n  private _handleEvent(event: string, ...args: any[]) {\n    const listeners = this._eventListeners.get(event);\n\n    if (listeners) {\n      listeners.forEach((listener) => {\n        try {\n          listener(...args);\n        } catch (e: unknown) {\n          console.error(`Error in event listener for ${event}:`, e);\n        }\n      });\n    }\n\n    // Also trigger listeners for the \"*\" event\n    const allListeners = this._eventListeners.get(\"*\");\n\n    if (allListeners) {\n      allListeners.forEach((listener) => {\n        try {\n          listener(event, ...args);\n        } catch (e: unknown) {\n          console.error(`Error in \"*\" event listener for ${event}:`, e);\n        }\n      });\n    }\n  }\n\n  /**\n   * Forward an event to all child frames\n   * @param event The event name\n   * @param args The event arguments\n   */\n  private _forwardEventToChildFrames(event: string, args: unknown[]) {\n    // Send the event to all child frames\n    this._childFrames.forEach((frame) => {\n      try {\n        frame.postMessage(\n          {\n            event,\n            args,\n          },\n          this._targetOrigin,\n        );\n      } catch (e: unknown) {\n        console.error(`Error forwarding event to child frame:`, e);\n      }\n    });\n  }\n\n  /**\n   * Send a message to the server-side facade\n   * @param method The method to call\n   * @param params The parameters to pass to the method\n   * @returns A promise that resolves with the result of the method call\n   */\n  private _sendMessage(\n    method: string,\n    params: (string | number | boolean)[] = [],\n  ): Promise<unknown> {\n    // In test environments, we need to handle the case where window.parent.postMessage\n    // might not be properly mocked, which can lead to unhandled promise rejections\n    if (\n      typeof window === \"undefined\" ||\n      typeof window.parent === \"undefined\" ||\n      typeof window.parent.postMessage !== \"function\"\n    ) {\n      // Return a resolved promise with an empty string in test environments\n      return Promise.resolve(\"\");\n    }\n\n    return new Promise((resolve, reject) => {\n      const messageId = `${Date.now()}-${this._messageIdCounter++}`;\n\n      // Store the promise callbacks\n      this._pendingRequests.set(messageId, { resolve, reject });\n\n      try {\n        // Send the message to the parent frame\n        window.parent.postMessage(\n          {\n            messageId,\n            method,\n            params,\n          },\n          this._targetOrigin,\n        );\n\n        // Set a timeout to reject the promise if no response is received\n        setTimeout(() => {\n          if (this._pendingRequests.has(messageId)) {\n            this._pendingRequests.delete(messageId);\n            reject(new Error(`Timeout waiting for response to method ${method}`));\n          }\n        }, 5000);\n      } catch (e) {\n        // If there's an error sending the message, clean up and reject the promise\n        this._pendingRequests.delete(messageId);\n        reject(e);\n      }\n    });\n  }\n\n  /**\n   * Initialize the SCORM API (SCORM 1.2 style) - Asynchronous version\n   * @returns Promise that resolves to true if initialization was successful\n   */\n  async initialize(): Promise<boolean> {\n    const result = await this._sendMessage(\"lmsInitialize\");\n    this._isInitialized = result === \"true\";\n    return this._isInitialized;\n  }\n\n  /**\n   * Initialize the SCORM API (SCORM 1.2 style) - Synchronous version\n   * @returns \"true\" if initialization was successful, \"false\" otherwise\n   */\n  lmsInitialize(): string {\n    try {\n      return String(this._syncCall(\"lmsInitialize\", []));\n    } catch (e) {\n      this._lastError = \"101\";\n      return \"false\";\n    }\n  }\n\n  /**\n   * Initialize the SCORM API (SCORM 2004 style) - Asynchronous version\n   * @returns Promise that resolves to true if initialization was successful\n   */\n  async Initialize(): Promise<boolean> {\n    return this.initialize();\n  }\n\n  /**\n   * Initialize the SCORM API (SCORM 2004 style) - Synchronous version\n   * @returns \"true\" if initialization was successful, \"false\" otherwise\n   */\n  LMSInitialize(): string {\n    try {\n      return String(this._syncCall(\"LMSInitialize\", []));\n    } catch (e) {\n      this._lastError = \"101\";\n      return \"false\";\n    }\n  }\n\n  /**\n   * Terminate the SCORM API (SCORM 1.2 style) - Asynchronous version\n   * @returns Promise that resolves to true if termination was successful\n   */\n  async terminate(): Promise<boolean> {\n    const result = await this._sendMessage(\"lmsFinish\");\n    const success = result === \"true\";\n    if (success) {\n      this._isInitialized = false;\n    }\n    return success;\n  }\n\n  /**\n   * Terminate the SCORM API (SCORM 1.2 style) - Synchronous version\n   * @returns \"true\" if termination was successful, \"false\" otherwise\n   */\n  lmsFinish(): string {\n    try {\n      return String(this._syncCall(\"lmsFinish\", []));\n    } catch (e) {\n      this._lastError = \"101\";\n      return \"false\";\n    }\n  }\n\n  /**\n   * Terminate the SCORM API (SCORM 2004 style) - Asynchronous version\n   * @returns Promise that resolves to true if termination was successful\n   */\n  async Terminate(): Promise<boolean> {\n    return this.terminate();\n  }\n\n  /**\n   * Terminate the SCORM API (SCORM 2004 style) - Synchronous version\n   * @returns \"true\" if termination was successful, \"false\" otherwise\n   */\n  LMSFinish(): string {\n    try {\n      return String(this._syncCall(\"LMSFinish\", []));\n    } catch (e) {\n      this._lastError = \"101\";\n      return \"false\";\n    }\n  }\n\n  /**\n   * Get a value from the SCORM API (SCORM 1.2 style) - Asynchronous version\n   * @param element The CMI element to get\n   * @returns Promise that resolves to the value of the CMI element\n   */\n  async getValue(element: string): Promise<string> {\n    try {\n      const result = await this._sendMessage(\"lmsGetValue\", [element]);\n      const value = String(result);\n      // Cache the result for synchronous operations\n      this._cache.set(element, value);\n      return value;\n    } catch (e) {\n      this._lastError = \"101\"; // General exception\n      console.error(`Error in getValue(${element}):`, e);\n      return \"\";\n    }\n  }\n\n  /**\n   * Get a value from the SCORM API (SCORM 1.2 style) - Synchronous version\n   * @param element The CMI element to get\n   * @returns The value of the CMI element\n   */\n  lmsGetValue(element: string): string {\n    try {\n      return String(this._syncCall(\"lmsGetValue\", [element]));\n    } catch (e) {\n      this._lastError = \"101\";\n      return \"\";\n    }\n  }\n\n  /**\n   * Get a value from the SCORM API (SCORM 2004 style) - Asynchronous version\n   * @param element The CMI element to get\n   * @returns Promise that resolves to the value of the CMI element\n   */\n  async GetValue(element: string): Promise<string> {\n    return this.getValue(element);\n  }\n\n  /**\n   * Get a value from the SCORM API (SCORM 2004 style) - Synchronous version\n   * @param element The CMI element to get\n   * @returns The value of the CMI element\n   */\n  LMSGetValue(element: string): string {\n    try {\n      return String(this._syncCall(\"LMSGetValue\", [element]));\n    } catch (e) {\n      this._lastError = \"101\";\n      return \"\";\n    }\n  }\n\n  /**\n   * Set a value in the SCORM API (SCORM 1.2 style) - Asynchronous version\n   * @param element The CMI element to set\n   * @param value The value to set\n   * @returns Promise that resolves to true if the value was set successfully\n   */\n  async setValue(element: string, value: string | number | boolean): Promise<boolean> {\n    try {\n      const result = await this._sendMessage(\"lmsSetValue\", [element, value]);\n      const success = result === \"true\";\n      if (success) {\n        // Update the cache with the new value\n        this._cache.set(element, String(value));\n      }\n      return success;\n    } catch (e) {\n      this._lastError = \"101\"; // General exception\n      console.error(`Error in setValue(${element}, ${value}):`, e);\n      return false;\n    }\n  }\n\n  /**\n   * Set a value in the SCORM API (SCORM 1.2 style) - Synchronous version\n   * @param element The CMI element to set\n   * @param value The value to set\n   * @returns \"true\" if the value was set successfully, \"false\" otherwise\n   */\n  lmsSetValue(element: string, value: string | number | boolean): string {\n    try {\n      return String(this._syncCall(\"lmsSetValue\", [element, value]));\n    } catch (e) {\n      this._lastError = \"101\";\n      return \"false\";\n    }\n  }\n\n  /**\n   * Set a value in the SCORM API (SCORM 2004 style) - Asynchronous version\n   * @param element The CMI element to set\n   * @param value The value to set\n   * @returns Promise that resolves to true if the value was set successfully\n   */\n  async SetValue(element: string, value: string | number | boolean): Promise<boolean> {\n    return this.setValue(element, value);\n  }\n\n  /**\n   * Set a value in the SCORM API (SCORM 2004 style) - Synchronous version\n   * @param element The CMI element to set\n   * @param value The value to set\n   * @returns \"true\" if the value was set successfully, \"false\" otherwise\n   */\n  LMSSetValue(element: string, value: string | number | boolean): string {\n    try {\n      return String(this._syncCall(\"LMSSetValue\", [element, value]));\n    } catch (e) {\n      this._lastError = \"101\";\n      return \"false\";\n    }\n  }\n\n  /**\n   * Commit changes to the LMS (SCORM 1.2 style) - Asynchronous version\n   * @returns Promise that resolves to true if the commit was successful\n   */\n  async commit(): Promise<boolean> {\n    try {\n      const result = await this._sendMessage(\"lmsCommit\");\n      return result === \"true\";\n    } catch (e) {\n      this._lastError = \"101\"; // General exception\n      console.error(\"Error in commit:\", e);\n      return false;\n    }\n  }\n\n  /**\n   * Commit changes to the LMS (SCORM 1.2 style) - Synchronous version\n   * @returns \"true\" if the commit was successful, \"false\" otherwise\n   */\n  lmsCommit(): string {\n    try {\n      return String(this._syncCall(\"lmsCommit\", []));\n    } catch (e) {\n      this._lastError = \"101\";\n      return \"false\";\n    }\n  }\n\n  /**\n   * Commit changes to the LMS (SCORM 2004 style) - Asynchronous version\n   * @returns Promise that resolves to true if the commit was successful\n   */\n  async Commit(): Promise<boolean> {\n    return this.commit();\n  }\n\n  /**\n   * Commit changes to the LMS (SCORM 2004 style) - Synchronous version\n   * @returns \"true\" if the commit was successful, \"false\" otherwise\n   */\n  LMSCommit(): string {\n    try {\n      return String(this._syncCall(\"LMSCommit\", []));\n    } catch (e) {\n      this._lastError = \"101\";\n      return \"false\";\n    }\n  }\n\n  /**\n   * Get the last error code (SCORM 1.2 style) - Asynchronous version\n   * @returns Promise that resolves to the last error code as a string\n   */\n  async getLastError(): Promise<string> {\n    try {\n      const result = await this._sendMessage(\"lmsGetLastError\");\n      this._lastError = String(result);\n      return this._lastError;\n    } catch (e) {\n      console.error(\"Error in getLastError:\", e);\n      return \"101\"; // General exception\n    }\n  }\n\n  /**\n   * Get the last error code (SCORM 1.2 style) - Synchronous version\n   * @returns The last error code as a string\n   */\n  lmsGetLastError(): string {\n    try {\n      return String(this._syncCall(\"lmsGetLastError\", []));\n    } catch (e) {\n      return \"101\";\n    }\n  }\n\n  /**\n   * Get the last error code (SCORM 2004 style) - Asynchronous version\n   * @returns Promise that resolves to the last error code as a string\n   */\n  async GetLastError(): Promise<string> {\n    return this.getLastError();\n  }\n\n  /**\n   * Get the last error code (SCORM 2004 style) - Synchronous version\n   * @returns The last error code as a string\n   */\n  LMSGetLastError(): string {\n    try {\n      return String(this._syncCall(\"LMSGetLastError\", []));\n    } catch (e) {\n      return \"101\";\n    }\n  }\n\n  /**\n   * Get the error string for an error code (SCORM 1.2 style) - Asynchronous version\n   * @param errorCode The error code\n   * @returns Promise that resolves to the error string\n   */\n  async getErrorString(errorCode: string | number): Promise<string> {\n    try {\n      const result = await this._sendMessage(\"lmsGetErrorString\", [errorCode]);\n      const errorString = String(result);\n      // Cache the result for synchronous operations\n      this._cache.set(`error_${errorCode}`, errorString);\n      return errorString;\n    } catch (e) {\n      console.error(`Error in getErrorString(${errorCode}):`, e);\n      return \"\";\n    }\n  }\n\n  /**\n   * Get the error string for an error code (SCORM 1.2 style) - Synchronous version\n   * @param errorCode The error code\n   * @returns The error string\n   */\n  lmsGetErrorString(errorCode: string | number): string {\n    try {\n      return String(this._syncCall(\"lmsGetErrorString\", [errorCode]));\n    } catch (e) {\n      return \"No error\";\n    }\n  }\n\n  /**\n   * Get the error string for an error code (SCORM 2004 style) - Asynchronous version\n   * @param errorCode The error code\n   * @returns Promise that resolves to the error string\n   */\n  async GetErrorString(errorCode: string | number): Promise<string> {\n    return this.getErrorString(errorCode);\n  }\n\n  /**\n   * Get the error string for an error code (SCORM 2004 style) - Synchronous version\n   * @param errorCode The error code\n   * @returns The error string\n   */\n  LMSGetErrorString(errorCode: string | number): string {\n    try {\n      return String(this._syncCall(\"LMSGetErrorString\", [errorCode]));\n    } catch (e) {\n      return \"No error\";\n    }\n  }\n\n  /**\n   * Get diagnostic information for an error code (SCORM 1.2 style) - Asynchronous version\n   * @param errorCode The error code\n   * @returns Promise that resolves to the diagnostic information\n   */\n  async getDiagnostic(errorCode: string | number): Promise<string> {\n    try {\n      const result = await this._sendMessage(\"lmsGetDiagnostic\", [errorCode]);\n      const diagnostic = String(result);\n      // Cache the result for synchronous operations\n      this._cache.set(`diagnostic_${errorCode}`, diagnostic);\n      return diagnostic;\n    } catch (e) {\n      console.error(`Error in getDiagnostic(${errorCode}):`, e);\n      return \"\";\n    }\n  }\n\n  /**\n   * Get diagnostic information for an error code (SCORM 1.2 style) - Synchronous version\n   * @param errorCode The error code\n   * @returns The diagnostic information\n   */\n  lmsGetDiagnostic(errorCode: string | number): string {\n    try {\n      return String(this._syncCall(\"lmsGetDiagnostic\", [errorCode]));\n    } catch (e) {\n      return \"No diagnostic information available\";\n    }\n  }\n\n  /**\n   * Get diagnostic information for an error code (SCORM 2004 style) - Asynchronous version\n   * @param errorCode The error code\n   * @returns Promise that resolves to the diagnostic information\n   */\n  async GetDiagnostic(errorCode: string | number): Promise<string> {\n    return this.getDiagnostic(errorCode);\n  }\n\n  /**\n   * Get diagnostic information for an error code (SCORM 2004 style) - Synchronous version\n   * @param errorCode The error code\n   * @returns The diagnostic information\n   */\n  LMSGetDiagnostic(errorCode: string | number): string {\n    try {\n      return String(this._syncCall(\"LMSGetDiagnostic\", [errorCode]));\n    } catch (e) {\n      return \"No diagnostic information available\";\n    }\n  }\n\n  /**\n   * Check if the API is currently initialized - Asynchronous version\n   * @returns Promise that resolves to true if the API is initialized\n   */\n  async isInitialized(): Promise<boolean> {\n    try {\n      const result = await this._sendMessage(\"isInitialized\");\n      this._isInitialized = Boolean(result);\n      return this._isInitialized;\n    } catch (e) {\n      console.error(\"Error in isInitialized:\", e);\n      return this._isInitialized;\n    }\n  }\n\n  /**\n   * Check if the API is currently initialized - Synchronous version\n   * @returns True if the API is initialized, false otherwise\n   */\n  getIsInitialized(): boolean {\n    // In test environments, starting an async operation can cause issues\n    // with unhandled promise rejections, so we'll just return the current value\n    return this._isInitialized;\n  }\n\n  /**\n   * Register an event listener\n   * @param event The event name\n   * @param callback The callback function\n   */\n  on(event: string, callback: (...args: unknown[]) => void): void {\n    if (!this._eventListeners.has(event)) {\n      this._eventListeners.set(event, new Set());\n    }\n\n    const listeners = this._eventListeners.get(event);\n    if (listeners) {\n      listeners.add(callback);\n    }\n  }\n\n  /**\n   * Remove an event listener\n   * @param event The event name\n   * @param callback The callback function\n   */\n  off(event: string, callback: (...args: unknown[]) => void): void {\n    const listeners = this._eventListeners.get(event);\n\n    if (listeners) {\n      listeners.delete(callback);\n\n      if (listeners.size === 0) {\n        this._eventListeners.delete(event);\n      }\n    }\n  }\n}\n\n/**\n * Factory function to create a CrossFrameServer instance\n * @param {BaseAPI} api The API instance to use\n * @param targetOrigin The target origin for postMessage\n * @returns A CrossFrameServer instance\n */\nexport function createCrossFrameServer(api: BaseAPI, targetOrigin?: string): CrossFrameLMS {\n  return new CrossFrameLMS(api, targetOrigin);\n}\n\n/**\n * Factory function to create a CrossFrameClient instance\n * @param targetOrigin The target origin for postMessage\n * @returns A CrossFrameClient instance\n */\nexport function createCrossFrameClient(targetOrigin?: string): CrossFrameAPI {\n  return new CrossFrameAPI(targetOrigin);\n}\n"],"names":["CrossFrameLMS","constructor","api","targetOrigin","this","_targetOrigin","_api","window","addEventListener","_handleMessage","bind","_setupEventForwarding","event","data","messageId","method","_processMessage","source","origin","params","sab","result","error","Error","e","message","stack","String","response","postMessage","_this","on","_len","arguments","length","args","Array","_key","frames","from","document","querySelectorAll","forEach","frame","contentWindow","CrossFrameAPI","_pendingRequests","Map","_eventListeners","_messageIdCounter","_childFrames","Set","_isInitialized","_lastError","_cache","_sabBuffers","_syncCall","timeoutMs","undefined","SharedArrayBuffer","Int32Array","BYTES_PER_ELEMENT","int32","Date","now","set","parent","status","Atomics","wait","delete","pending","get","isFromChildFrame","_handleMethodResponse","add","forwardedMessageId","resolve","reject","setTimeout","has","request","_handleEvent","_forwardEventToChildFrames","store","notify","pendingRequest","_len2","_key2","listeners","listener","console","allListeners","_sendMessage","Promise","initialize","lmsInitialize","Initialize","LMSInitialize","terminate","success","lmsFinish","Terminate","LMSFinish","getValue","element","value","lmsGetValue","GetValue","LMSGetValue","setValue","lmsSetValue","SetValue","LMSSetValue","commit","lmsCommit","Commit","LMSCommit","getLastError","lmsGetLastError","GetLastError","LMSGetLastError","getErrorString","errorCode","errorString","lmsGetErrorString","GetErrorString","LMSGetErrorString","getDiagnostic","diagnostic","lmsGetDiagnostic","GetDiagnostic","LMSGetDiagnostic","isInitialized","Boolean","getIsInitialized","callback","off","size","createCrossFrameServer","createCrossFrameClient"],"mappings":"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"}