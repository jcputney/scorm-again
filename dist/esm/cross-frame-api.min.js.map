{"version":3,"file":"cross-frame-api.min.js","sources":["../../src/CrossFrameAPI.ts"],"sourcesContent":["// src/CrossFrameAPI.ts\nimport { MessageData, MessageResponse } from \"./types/CrossFrame\";\nimport { global_errors } from \"./constants/error_codes\";\n\n/**\n * Client-side SCORM façade running in your content frame.\n * Returns cached/default values synchronously, then fires off an async\n * postMessage to the LMS frame to refresh cache and error state.\n */\nexport default class CrossFrameAPI {\n  private _cache = new Map<string, string>();\n  private _lastError = \"0\";\n  private _pending = new Map<\n    string,\n    {\n      resolve: (v: any) => void;\n      reject: (e: any) => void;\n      timer: ReturnType<typeof setTimeout>;\n    }\n  >();\n  private _counter = 0;\n  private readonly _origin: string;\n  private readonly _targetWindow: Window;\n\n  private _handler: ProxyHandler<CrossFrameAPI> = {\n    get: (target, prop, receiver) => {\n      // If it's an existing property/method, return it\n      if (typeof prop !== \"string\" || prop in target) {\n        const v = Reflect.get(target, prop, receiver);\n        return typeof v === \"function\" ? v.bind(target) : v;\n      }\n\n      // Otherwise treat prop as a SCORM call\n      const methodName = prop;\n      const isGet = methodName.endsWith(\"GetValue\");\n      const isSet = methodName.startsWith(\"LMSSet\") || methodName.endsWith(\"SetValue\");\n      const isInit = methodName === \"Initialize\" || methodName === \"LMSInitialize\";\n      const isFinish = methodName === \"Terminate\" || methodName === \"LMSFinish\";\n      const isCommit = methodName === \"Commit\" || methodName === \"LMSCommit\";\n      const isErrorString = methodName === \"GetErrorString\" || methodName === \"LMSGetErrorString\";\n      const isDiagnostic = methodName === \"GetDiagnostic\" || methodName === \"LMSGetDiagnostic\";\n\n      return (...args: any[]): string => {\n        // Synchronous cache update for setter calls\n        if (isSet && args.length >= 2) {\n          target._cache.set(args[0], String(args[1]));\n          target._lastError = \"0\";\n        }\n\n        // Fire off async postMessage to refresh cache and error\n        target\n          ._post(methodName, args)\n          .then((res) => {\n            if (isGet && args.length >= 1) {\n              target._cache.set(args[0], String(res));\n              target._lastError = \"0\";\n            }\n            if (isErrorString && args.length >= 1) {\n              const code = String(args[0]);\n              target._cache.set(`error_${code}`, String(res));\n            }\n            if (isDiagnostic && args.length >= 1) {\n              const code = String(args[0]);\n              target._cache.set(`diag_${code}`, String(res));\n            }\n            if (methodName === \"GetLastError\" || methodName === \"LMSGetLastError\") {\n              target._lastError = String(res);\n            }\n          })\n          .catch((err) => target._capture(methodName, err));\n\n        // Return synchronously\n        if (isGet && args.length >= 1) {\n          return target._cache.get(args[0]) ?? \"\";\n        }\n        if (isErrorString && args.length >= 1) {\n          const code = String(args[0]);\n          return target._cache.get(`error_${code}`) ?? \"\";\n        }\n        if (isDiagnostic && args.length >= 1) {\n          const code = String(args[0]);\n          return target._cache.get(`diag_${code}`) ?? \"\";\n        }\n        if (isInit || isFinish || isCommit || isSet) {\n          // Immediately return “true”\n          const result = \"true\";\n          // Then warm cache:\n          target\n            ._post(\"getFlattenedCMI\", [])\n            .then((all: Record<string, string>) => {\n              Object.entries(all).forEach(([key, val]) => {\n                target._cache.set(key, val);\n              });\n              // reset error\n              target._lastError = \"0\";\n            })\n            .catch((err) => target._capture(\"getFlattenedCMI\", err));\n          return result;\n        }\n        if (methodName === \"GetLastError\" || methodName === \"LMSGetLastError\") {\n          return target._lastError;\n        }\n        return \"\";\n      };\n    },\n  };\n\n  constructor(targetOrigin: string = \"*\", targetWindow: Window = window.parent) {\n    this._origin = targetOrigin;\n    this._targetWindow = targetWindow;\n    window.addEventListener(\"message\", this._onMessage.bind(this));\n    return new Proxy(this, this._handler);\n  }\n\n  /** Send a message to the LMS frame and return a promise for its response */\n  private _post(method: string, params: any[]): Promise<any> {\n    const messageId = `cfapi-${Date.now()}-${this._counter++}`;\n\n    // Deep‐clean params of non-cloneables (e.g. functions)\n    const safeParams = params.map((p) => {\n      if (typeof p === \"function\") {\n        console.warn(\"Dropping function param when posting SCORM call:\", method);\n        return undefined;\n      }\n      return p;\n    });\n\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        if (this._pending.has(messageId)) {\n          this._pending.delete(messageId);\n          reject(new Error(`Timeout calling ${method}`));\n        }\n      }, 5000);\n\n      this._pending.set(messageId, { resolve, reject, timer });\n      const msg: MessageData = { messageId, method, params: safeParams };\n      this._targetWindow.postMessage(msg, this._origin);\n    });\n  }\n\n  /** Handle incoming postMessage responses from the LMS frame */\n  private _onMessage(ev: MessageEvent) {\n    // Validate the message origin and source unless all origins are allowed\n    if (this._origin !== \"*\" && ev.origin !== this._origin) {\n      return;\n    }\n    if (ev.source && ev.source !== this._targetWindow) {\n      return;\n    }\n    const data = ev.data as MessageResponse;\n    if (!data?.messageId) return;\n    const pending = this._pending.get(data.messageId);\n    if (!pending) return;\n    clearTimeout(pending.timer);\n    this._pending.delete(data.messageId);\n    if (data.error) pending.reject(data.error);\n    else pending.resolve(data.result);\n  }\n\n  /** Capture and cache SCORM errors */\n  private _capture(method: string, err: any) {\n    console.error(`CrossFrameAPI ${method} error:`, err);\n    const match = /\\b(\\d{3})\\b/.exec(err.message);\n    const code = match ? match[1] : String(global_errors.GENERAL);\n    this._lastError = code;\n    this._cache.set(`error_${code}`, err.message);\n  }\n}\n"],"names":["CrossFrameAPI","constructor","targetOrigin","targetWindow","window","parent","this","_cache","Map","_lastError","_pending","_counter","_handler","get","target","prop","receiver","v","Reflect","bind","methodName","isGet","endsWith","isSet","startsWith","isInit","isFinish","isCommit","isErrorString","isDiagnostic","args","length","set","String","_post","then","res","catch","err","_capture","result","all","Object","entries","forEach","key","val","_origin","_targetWindow","addEventListener","_onMessage","Proxy","method","params","messageId","Date","now","safeParams","map","p","console","warn","Promise","resolve","reject","timer","setTimeout","has","delete","Error","postMessage","ev","origin","source","data","pending","clearTimeout","error","match","exec","message","code"],"mappings":"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"}