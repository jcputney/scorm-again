{"version":3,"file":"cross-frame-api.min.js","sources":["../../src/CrossFrameAPI.ts"],"sourcesContent":["// src/CrossFrameAPI.ts\nimport {\n  CrossFrameAPIOptions,\n  CrossFrameEvent,\n  CrossFrameEventCallback,\n  MessageData,\n  MessageResponse,\n} from \"./types/CrossFrame\";\nimport { global_errors } from \"./constants/error_codes\";\n\n/**\n * Pending request tracking with timestamp for cache merge protection\n */\ninterface PendingRequest {\n  resolve: (v: unknown) => void;\n  reject: (e: unknown) => void;\n  timer: ReturnType<typeof setTimeout>;\n  /**\n   * Timestamp when the request was sent, used for cache merge protection.\n   * Ensures local modifications made after the request was sent aren't overwritten\n   * by stale server responses that arrive later.\n   */\n  requestTime: number;\n  method: string; // CF-API-02: Track method name for better error reporting\n}\n\n/**\n * Client-side SCORM facade running in your content frame.\n * Returns cached values synchronously, then fires off an async\n * postMessage to the LMS frame to refresh cache and error state.\n */\nexport default class CrossFrameAPI {\n  private _cache = new Map<string, string>();\n  private _cacheTimestamps = new Map<string, number>();\n  private _lastError = \"0\";\n  private _pending = new Map<string, PendingRequest>();\n  private _counter = 0;\n  private readonly _origin: string;\n  private readonly _targetWindow: Window;\n  private readonly _timeout: number;\n  private readonly _heartbeatInterval: number;\n  private readonly _heartbeatTimeout: number;\n\n  private _destroyed = false;\n  private _connected = true;\n  private _lastHeartbeatResponse = Date.now();\n  private _heartbeatTimer: ReturnType<typeof setInterval> | undefined;\n  private _eventListeners = new Map<string, Set<CrossFrameEventCallback>>();\n  private readonly _boundOnMessage: (ev: MessageEvent) => void;\n\n  /**\n   * Type guard to validate MessageResponse structure\n   */\n  private static _isValidMessageResponse(data: unknown): data is MessageResponse {\n    if (typeof data !== \"object\" || data === null) return false;\n\n    const resp = data as Partial<MessageResponse>;\n\n    // messageId is required\n    if (typeof resp.messageId !== \"string\" || resp.messageId.length === 0) return false;\n\n    // error must have correct shape if present\n    if (resp.error !== undefined) {\n      if (typeof resp.error !== \"object\" || resp.error === null) return false;\n      const err = resp.error as Record<string, unknown>;\n      if (typeof err.message !== \"string\") return false;\n      if (err.code !== undefined && typeof err.code !== \"string\") return false;\n    }\n\n    // isHeartbeat must be boolean if present\n    if (resp.isHeartbeat !== undefined && typeof resp.isHeartbeat !== \"boolean\") return false;\n\n    return true;\n  }\n\n  /**\n   * Validates that args is an array and sanitizes it for safe use\n   */\n  private static _validateArgs(args: unknown[]): args is unknown[] {\n    if (!Array.isArray(args)) return false;\n    // Additional validation could check for specific types based on method\n    return true;\n  }\n\n  private _handler: ProxyHandler<CrossFrameAPI> = {\n    get: (target, prop, receiver) => {\n      // If it's an existing property/method, return it\n      if (typeof prop !== \"string\" || prop in target) {\n        const v = Reflect.get(target, prop, receiver);\n        return typeof v === \"function\" ? v.bind(target) : v;\n      }\n\n      // Otherwise treat prop as a SCORM call\n      const methodName = prop;\n      const isGet = methodName.endsWith(\"GetValue\");\n      const isSet = methodName.startsWith(\"LMSSet\") || methodName.endsWith(\"SetValue\");\n      const isInit = methodName === \"Initialize\" || methodName === \"LMSInitialize\";\n      const isFinish = methodName === \"Terminate\" || methodName === \"LMSFinish\";\n      const isCommit = methodName === \"Commit\" || methodName === \"LMSCommit\";\n      const isErrorString = methodName === \"GetErrorString\" || methodName === \"LMSGetErrorString\";\n      const isDiagnostic = methodName === \"GetDiagnostic\" || methodName === \"LMSGetDiagnostic\";\n\n      return (...args: unknown[]): string => {\n        // CF-API-03: Validate args is an array (TypeScript guarantees this, but runtime safety)\n        if (!CrossFrameAPI._validateArgs(args)) {\n          console.error(`CrossFrameAPI: Invalid arguments for ${methodName}`);\n          return \"\";\n        }\n\n        // Synchronous cache update for setter calls\n        if (isSet && args.length >= 2) {\n          const key = args[0] as string;\n          target._cache.set(key, String(args[1]));\n          target._cacheTimestamps.set(key, Date.now());\n          target._lastError = \"0\";\n        }\n\n        // Capture request time for cache merge protection\n        const requestTime = Date.now();\n\n        // Fire off async postMessage to refresh cache and error\n        target\n          ._post(methodName, args)\n          .then((res) => {\n            if (isGet && args.length >= 1) {\n              const key = args[0] as string;\n              // Only update if not locally modified after request was sent\n              const localModTime = target._cacheTimestamps.get(key) ?? 0;\n              if (localModTime < requestTime) {\n                target._cache.set(key, String(res));\n                target._cacheTimestamps.delete(key);\n              }\n              target._lastError = \"0\";\n            }\n            if (isErrorString && args.length >= 1) {\n              const code = String(args[0]);\n              target._cache.set(`error_${code}`, String(res));\n            }\n            if (isDiagnostic && args.length >= 1) {\n              const code = String(args[0]);\n              target._cache.set(`diag_${code}`, String(res));\n            }\n            if (methodName === \"GetLastError\" || methodName === \"LMSGetLastError\") {\n              target._lastError = String(res);\n            }\n          })\n          .catch((err) => target._capture(methodName, err));\n\n        // Return synchronously\n        if (isGet && args.length >= 1) {\n          return target._cache.get(args[0] as string) ?? \"\";\n        }\n        if (isErrorString && args.length >= 1) {\n          const code = String(args[0]);\n          return target._cache.get(`error_${code}`) ?? \"\";\n        }\n        if (isDiagnostic && args.length >= 1) {\n          const code = String(args[0]);\n          return target._cache.get(`diag_${code}`) ?? \"\";\n        }\n        if (isInit || isFinish || isCommit || isSet) {\n          // Immediately return \"true\"\n          const result = \"true\";\n          // Then warm cache with timestamp protection:\n          target\n            ._post(\"getFlattenedCMI\", [])\n            .then((all: unknown) => {\n              if (all && typeof all === \"object\") {\n                const entries = Object.entries(all as Record<string, string>);\n                entries.forEach(([key, val]) => {\n                  // Only update if not locally modified after request was sent\n                  const localModTime = target._cacheTimestamps.get(key) ?? 0;\n                  if (localModTime < requestTime) {\n                    target._cache.set(key, val);\n                    target._cacheTimestamps.delete(key);\n                  }\n                });\n              }\n              // reset error\n              target._lastError = \"0\";\n            })\n            .catch((err) => target._capture(\"getFlattenedCMI\", err));\n          return result;\n        }\n        if (methodName === \"GetLastError\" || methodName === \"LMSGetLastError\") {\n          return target._lastError;\n        }\n        return \"\";\n      };\n    },\n  };\n\n  /**\n   * Creates a new CrossFrameAPI instance.\n   * @param targetOrigin - Origin to send messages to. Default \"*\" sends to any origin.\n   * @param targetWindow - Window to send messages to. Default is window.parent.\n   * @param options - Configuration options\n   */\n  constructor(\n    targetOrigin: string = \"*\",\n    targetWindow: Window = window.parent,\n    options: CrossFrameAPIOptions = {},\n  ) {\n    this._origin = targetOrigin;\n    this._targetWindow = targetWindow;\n    this._timeout = options.timeout ?? 5000;\n    this._heartbeatInterval = options.heartbeatInterval ?? 30000;\n    this._heartbeatTimeout = options.heartbeatTimeout ?? 60000;\n\n    // Warn about wildcard origin security implications\n    if (targetOrigin === \"*\") {\n      console.warn(\n        \"CrossFrameAPI: Using wildcard origin ('*') allows any origin to receive messages. \" +\n          \"This is insecure for production use. \" +\n          \"Specify an explicit origin (e.g., 'https://lms.example.com') to restrict message recipients.\",\n      );\n    }\n\n    this._boundOnMessage = this._onMessage.bind(this);\n    window.addEventListener(\"message\", this._boundOnMessage);\n    this._startHeartbeat();\n\n    return new Proxy(this, this._handler);\n  }\n\n  /**\n   * Destroys this instance, removing event listeners and preventing further message processing.\n   * Once destroyed, the instance cannot be reused.\n   */\n  destroy(): void {\n    if (this._destroyed) return;\n    this._destroyed = true;\n    window.removeEventListener(\"message\", this._boundOnMessage);\n    if (this._heartbeatTimer) {\n      clearInterval(this._heartbeatTimer);\n      this._heartbeatTimer = undefined;\n    }\n    // Reject all pending requests\n    for (const pending of Array.from(this._pending.values())) {\n      clearTimeout(pending.timer);\n      pending.reject(new Error(\"CrossFrameAPI destroyed\"));\n    }\n    this._pending.clear();\n    this._cache.clear();\n    this._cacheTimestamps.clear();\n    this._eventListeners.clear();\n  }\n\n  /**\n   * Subscribes to a CrossFrame event.\n   * @param event - Event type to listen for\n   * @param callback - Function to call when event occurs\n   */\n  on(event: string, callback: CrossFrameEventCallback): void {\n    if (!this._eventListeners.has(event)) {\n      this._eventListeners.set(event, new Set());\n    }\n    this._eventListeners.get(event)?.add(callback);\n  }\n\n  /**\n   * Unsubscribes from a CrossFrame event.\n   * @param event - Event type to stop listening for\n   * @param callback - Function to remove\n   */\n  off(event: string, callback: CrossFrameEventCallback): void {\n    this._eventListeners.get(event)?.delete(callback);\n  }\n\n  /**\n   * Returns whether the connection to the LMS frame is currently active.\n   */\n  get connected(): boolean {\n    return this._connected;\n  }\n\n  /**\n   * Emits an event to all registered listeners.\n   */\n  private _emit(event: CrossFrameEvent): void {\n    this._eventListeners.get(event.type)?.forEach((cb) => cb(event));\n  }\n\n  /**\n   * Starts the heartbeat mechanism for connection detection.\n   */\n  private _startHeartbeat(): void {\n    // CF-API-01: Clear any existing heartbeat timer before starting a new one\n    if (this._heartbeatTimer) {\n      clearInterval(this._heartbeatTimer);\n    }\n\n    this._heartbeatTimer = setInterval(() => {\n      if (this._destroyed) return;\n\n      // Check if we've missed heartbeats\n      const timeSinceLastResponse = Date.now() - this._lastHeartbeatResponse;\n      if (timeSinceLastResponse > this._heartbeatTimeout && this._connected) {\n        this._connected = false;\n        this._emit({ type: \"connectionLost\" });\n      }\n\n      // Send heartbeat ping\n      this._sendHeartbeat();\n    }, this._heartbeatInterval);\n  }\n\n  /**\n   * Sends a heartbeat ping to the LMS frame.\n   */\n  private _sendHeartbeat(): void {\n    const messageId = `hb-${Date.now()}-${this._counter++}`;\n    const msg: MessageData = {\n      messageId,\n      method: \"__heartbeat__\",\n      params: [],\n      isHeartbeat: true,\n    };\n    this._targetWindow.postMessage(msg, this._origin);\n  }\n\n  /**\n   * Send a message to the LMS frame and return a promise for its response.\n   */\n  private _post(method: string, params: unknown[]): Promise<unknown> {\n    if (this._destroyed) {\n      return Promise.reject(new Error(\"CrossFrameAPI destroyed\"));\n    }\n\n    const messageId = `cfapi-${Date.now()}-${this._counter++}`;\n    const requestTime = Date.now();\n\n    // Deep-clean params of non-cloneables (e.g. functions)\n    const safeParams = params.map((p) => {\n      if (typeof p === \"function\") {\n        // DEFENSIVE CODING: Warn about non-serializable function parameters.\n        // This console.warn is intentionally kept in production builds because:\n        // 1. Functions in SCORM API params indicate a programming error by content authors\n        // 2. The warning helps diagnose integration issues during content development\n        // 3. It alerts developers to potential data loss (function becomes undefined)\n        // 4. The frequency should be very low in production (only on misconfigured content)\n        //\n        // Alternative: Could be gated by a debug flag if production console noise is a concern\n        console.warn(\"Dropping function param when posting SCORM call:\", method);\n        return undefined;\n      }\n      return p;\n    });\n\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        if (this._pending.has(messageId)) {\n          this._pending.delete(messageId);\n          reject(new Error(`Timeout calling ${method}`));\n        }\n      }, this._timeout);\n\n      // CF-API-02: Store method name in pending request for better error reporting\n      this._pending.set(messageId, { resolve, reject, timer, requestTime, method });\n      const msg: MessageData = { messageId, method, params: safeParams };\n      this._targetWindow.postMessage(msg, this._origin);\n    });\n  }\n\n  /**\n   * Handle incoming postMessage responses from the LMS frame.\n   */\n  private _onMessage(ev: MessageEvent): void {\n    if (this._destroyed) return;\n\n    // Validate the message origin and source unless all origins are allowed\n    if (this._origin !== \"*\" && ev.origin !== this._origin) {\n      return;\n    }\n    if (ev.source && ev.source !== this._targetWindow) {\n      return;\n    }\n\n    // CF-API-04: Validate that ev.data has the expected MessageResponse structure\n    if (!CrossFrameAPI._isValidMessageResponse(ev.data)) return;\n\n    const data = ev.data;\n\n    // Handle heartbeat response\n    if (data.isHeartbeat) {\n      this._lastHeartbeatResponse = Date.now();\n      if (!this._connected) {\n        this._connected = true;\n        this._emit({ type: \"connectionRestored\" });\n      }\n      return;\n    }\n\n    // Handle regular response\n    const pending = this._pending.get(data.messageId);\n    if (!pending) return;\n\n    clearTimeout(pending.timer);\n    this._pending.delete(data.messageId);\n\n    if (data.error) {\n      // Check if rate limited and emit event\n      // CF-API-02: Use the actual method name from the pending request\n      if (data.error.message === \"Rate limit exceeded\") {\n        this._emit({ type: \"rateLimited\", method: pending.method });\n      }\n      pending.reject(data.error);\n    } else {\n      pending.resolve(data.result);\n    }\n  }\n\n  /**\n   * Capture and cache SCORM errors.\n   */\n  private _capture(method: string, err: unknown): void {\n    let errorMessage = \"Unknown error\";\n\n    if (err instanceof Error) {\n      errorMessage = err.message;\n    } else if (typeof err === \"object\" && err !== null && \"message\" in err) {\n      errorMessage = String((err as { message: unknown }).message);\n    }\n\n    console.error(`CrossFrameAPI ${method} error:`, err);\n    // Match SCORM error codes (3 digits) from error messages\n    const match = /(?:error code|code)?\\s*(\\d{3})\\b/i.exec(errorMessage);\n    const code = match?.[1] ?? String(global_errors.GENERAL);\n    this._lastError = code;\n    this._cache.set(`error_${code}`, errorMessage);\n  }\n}\n"],"names":["CrossFrameAPI","constructor","targetOrigin","targetWindow","window","parent","options","this","_cache","Map","_cacheTimestamps","_lastError","_pending","_counter","_destroyed","_connected","_lastHeartbeatResponse","Date","now","_eventListeners","_handler","get","target","prop","receiver","v","Reflect","bind","methodName","isGet","endsWith","isSet","startsWith","isInit","isFinish","isCommit","isErrorString","isDiagnostic","args","_validateArgs","console","error","length","key","set","String","requestTime","_post","then","res","localModTime","delete","catch","err","_capture","result","all","Object","entries","forEach","val","_origin","_targetWindow","_timeout","timeout","_heartbeatInterval","heartbeatInterval","_heartbeatTimeout","heartbeatTimeout","warn","_boundOnMessage","_onMessage","addEventListener","_startHeartbeat","Proxy","_isValidMessageResponse","data","messageId","message","code","isHeartbeat","Array","isArray","destroy","removeEventListener","_heartbeatTimer","clearInterval","pending","from","values","clearTimeout","timer","reject","Error","clear","on","event","callback","has","Set","add","off","connected","_emit","type","cb","setInterval","_sendHeartbeat","postMessage","method","params","Promise","safeParams","map","p","resolve","setTimeout","ev","origin","source","errorMessage","match","exec"],"mappings":"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"}